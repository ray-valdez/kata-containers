//
// Copyright 2017 HyperHQ Inc.
// Copyright (c) 2019-2020 Ant Group
//
// SPDX-License-Identifier: Apache-2.0
//

syntax = "proto3";

option go_package = "github.com/kata-containers/kata-containers/src/runtime/virtcontainers/pkg/agent/protocols/grpc";

package  grpctls;

import "oci.proto";
import "types.proto";

import "google/protobuf/empty.proto";

// unstable
service SecAgentService {
	// execution
	rpc CreateContainer(CreateContainerRequest) returns (google.protobuf.Empty);
	rpc StartContainer(StartContainerRequest) returns (google.protobuf.Empty);

        // RemoveContainer will tear down an existing container by forcibly terminating
	// all processes running inside that container and releasing all internal
	// resources associated with it.
	// RemoveContainer will wait for all processes termination before returning.
	// If any process can not be killed or if it can not be killed after
	// the RemoveContainerRequest timeout, RemoveContainer will return an error.
	rpc RemoveContainer(RemoveContainerRequest) returns (google.protobuf.Empty);
	rpc ExecProcess(ExecProcessRequest) returns (google.protobuf.Empty);
        rpc SignalProcess(SignalProcessRequest) returns (google.protobuf.Empty);
	rpc WaitProcess(WaitProcessRequest) returns (WaitProcessResponse); 
        rpc UpdateContainer(UpdateContainerRequest) returns (google.protobuf.Empty);
        //rpc UpdateEphemeralMounts(UpdateEphemeralMountsRequest) returns (google.protobuf.Empty);
        //rpc StatsContainer(StatsContainerRequest) returns (StatsContainerResponse);
	rpc PauseContainer(PauseContainerRequest) returns (google.protobuf.Empty);
	rpc ResumeContainer(ResumeContainerRequest) returns (google.protobuf.Empty);

	// new api 
	rpc ListContainers(ListContainersRequest) returns(ContainerInfoList);

        // stdio
	rpc WriteStdin(WriteStreamRequest) returns (WriteStreamResponse);
	rpc ReadStdout(ReadStreamRequest) returns (ReadStreamResponse);
	rpc ReadStderr(ReadStreamRequest) returns (ReadStreamResponse);
	rpc CloseStdin(CloseStdinRequest) returns (google.protobuf.Empty);
	rpc TtyWinResize(TtyWinResizeRequest) returns (google.protobuf.Empty);

	// networking
        //rpc UpdateInterface(UpdateInterfaceRequest) returns (types.Interface);
	//rpc UpdateRoutes(UpdateRoutesRequest) returns (Routes);
	rpc ListInterfaces(ListInterfacesRequest) returns(Interfaces);
	rpc ListRoutes(ListRoutesRequest) returns (Routes);
	//rpc AddARPNeighbors(AddARPNeighborsRequest) returns (google.protobuf.Empty);
	//rpc GetIPTables(GetIPTablesRequest) returns (GetIPTablesResponse);
	//rpc SetIPTables(SetIPTablesRequest) returns (SetIPTablesResponse);

        // observability
        rpc GetMetrics(GetMetricsRequest) returns (Metrics);

        // Some host-side sandbox related APIs not supported over tenant-side

        // misc (TODO: some rpcs can be replaced by hyperstart-exec)
        // rpc CreateSandbox(CreateSandboxRequest) returns (google.protobuf.Empty);
        // rpc DestroySandbox(DestroySandboxRequest) returns (google.protobuf.Empty);
        rpc OnlineCPUMem(OnlineCPUMemRequest) returns (google.protobuf.Empty);
        rpc ReseedRandomDev(ReseedRandomDevRequest) returns (google.protobuf.Empty);
        // rpc GetGuestDetails(GuestDetailsRequest) returns (GuestDetailsResponse);
        // rpc MemHotplugByProbe(MemHotplugByProbeRequest) returns (google.protobuf.Empty);
        rpc SetGuestDateTime(SetGuestDateTimeRequest) returns (google.protobuf.Empty);
        rpc CopyFile(CopyFileRequest) returns (google.protobuf.Empty);
        rpc GetOOMEvent(GetOOMEventRequest) returns (OOMEvent);
        // rpc AddSwap(AddSwapRequest) returns (google.protobuf.Empty);
        // rpc GetVolumeStats(VolumeStatsRequest) returns (VolumeStatsResponse);
        // rpc ResizeVolume(ResizeVolumeRequest) returns (google.protobuf.Empty);
}

message CreateContainerRequest {
        string container_id = 1;
        string exec_id = 2;
        StringUser string_user = 3;
        repeated Device devices = 4;
        repeated Storage storages = 5;
        Spec OCI = 6;

        // This field is used to indicate if the container needs to join
        // sandbox shared pid ns or create a new namespace. This field is
        // meant to override the NEWPID config settings in the OCI spec.
        // The agent would receive an OCI spec with PID namespace cleared
        // out altogether and not just the pid ns path.
        bool sandbox_pidns = 7;
}

message StartContainerRequest {
    string container_id = 1;
}

message RemoveContainerRequest {
    string container_id = 1;
    uint32 timeout = 2;
}

message PauseContainerRequest {
    string container_id = 1;
}

message ResumeContainerRequest {
    string container_id = 1;
}

message ListContainersRequest {
}

message ContainerInfo {
    string container_id = 1;
    uint64 created = 2;
    string state = 3;
    string annotations = 4;
}

message ContainerInfoList {
   repeated ContainerInfo ContainerInfoList = 1; 
}

message ExecProcessRequest {
        string container_id = 1;
        string exec_id = 2;
        StringUser string_user = 3;
        Process process = 4;
}

message SignalProcessRequest {
	string container_id = 1;

	// Special case for SignalProcess(): exec_id can be empty(""),
	// which means to send the signal to all the processes including their descendants.
	// Other APIs with exec_id should treat empty exec_id as an invalid request.
	string exec_id = 2;
	uint32 signal = 3;
}

message WaitProcessRequest {
	string container_id = 1;
	string exec_id = 2;
}

message WaitProcessResponse {
	int32 status = 1;
}

message UpdateContainerRequest {
	string container_id = 1;
	LinuxResources resources = 2;
}

message WriteStreamRequest {
	string container_id = 1;
	string exec_id = 2;
	bytes data = 3;
}

message WriteStreamResponse {
	uint32 len = 1;
}

message ReadStreamRequest {
	string container_id = 1;
	string exec_id = 2;
	uint32 len = 3;
}

message ReadStreamResponse {
	bytes data = 1;
}

message CloseStdinRequest {
	string container_id = 1;
	string exec_id = 2;
}

message TtyWinResizeRequest {
	string container_id = 1;
	string exec_id = 2;
	uint32 row = 3;
	uint32 column = 4;
}

message Interfaces {
	repeated types.Interface Interfaces = 1;
}

message Routes {
	repeated types.Route Routes = 1;
}

message ListInterfacesRequest {
}

message ListRoutesRequest {
}

message OnlineCPUMemRequest {
	// Wait specifies if the caller waits for the agent to online all resources.
	// If true the agent returns once all resources have been connected, otherwise all
	// resources are connected asynchronously and the agent returns immediately.
	bool wait = 1;

	// NbCpus specifies the number of CPUs that should be onlined in the guest.
	// Special value 0 means agent will skip this check.
	uint32 nb_cpus = 2;

	// CpuOnly specifies whether only online CPU or not.
	bool cpu_only = 3;
}

message GetMetricsRequest {}

message Metrics {
	string metrics = 1;
}

message ReseedRandomDevRequest {
	// Data specifies the random data used to reseed the guest crng.
	bytes data = 2;
}

message SetGuestDateTimeRequest {
	// Sec the second since the Epoch.
	int64 Sec = 1;
	// Usec the microseconds portion of time since the Epoch.
	int64 Usec = 2;
}

message CopyFileRequest {
	// Path is the destination file in the guest. It must be absolute,
	// canonical and below /run.
	string path = 1;
	// FileSize is the expected file size, for security reasons write operations
	// are made in a temporary file, once it has the expected size, it's moved
	// to the destination path.
	int64 file_size = 2;
	// FileMode is the file mode.
	uint32 file_mode = 3;
	// DirMode is the mode for the parent directories of destination path.
	uint32 dir_mode = 4;
	// Uid is the numeric user id.
	int32 uid = 5;
	// Gid is the numeric group id.
	int32 gid = 6;
	// Offset for the next write operation.
	int64 offset = 7;
	// Data to write in the destination file.
	bytes data = 8;
}

message GetOOMEventRequest {}

message OOMEvent {
	string container_id = 1;
}
message StringUser {
       string uid = 1;
       string gid = 2;
       repeated string additionalGids = 3;
}

// Device represents only the devices that could have been defined through the
// Linux Device list of the OCI specification.
message Device {
        // Id can be used to identify the device inside the VM. Some devices
        // might not need it to be identified on the VM, and will rely on the
        // provided VmPath instead.
        string id = 1;
        // Type defines the type of device described. This can be "blk",
        // "scsi", "vfio", ...
        // Particularly, this should be used to trigger the use of the
        // appropriate device handler.
        string type = 2;
        // VmPath can be used by the caller to provide directly the path of
        // the device as it will appear inside the VM. For some devices, the
        // device id or the list of options passed might not be enough to find
        // the device. In those cases, the caller should predict and provide
        // this vm_path.
        string vm_path = 3;
        // ContainerPath defines the path where the device should be found inside
        // the container. This path should match the path of the device from
        // the device list listed inside the OCI spec. This is used in order
        // to identify the right device in the spec and update it with the
        // right options such as major/minor numbers as they appear inside
        // the VM for instance. Note that an empty ctr_path should be used
        // to make sure the device handler inside the agent is called, but
        // no spec update needs to be performed. This has to happen for the
        // case of rootfs, when a device has to be waited for after it has
        // been hotplugged. An equivalent Storage entry should be defined if
        // any mount needs to be performed afterwards.
        string container_path = 4;
        // Options allows the caller to define a list of options such as block
        // sizes, numbers of luns, ... which are very specific to every device
        // and cannot be generalized through extra fields.
        repeated string options = 5;
}


message KernelModule {
        // This field is the name of the kernel module.
        string name = 1;
        // This field are the parameters for the kernel module which are
        // whitespace-delimited key=value pairs passed to modprobe(8).
        repeated string parameters = 2;
}

//
// Some issues with referencing type as types.FSGroupChangePolicy
//
enum FSGroupChangePolicy {
        // Always indicates that the volume ownership will always be changed.
        Always = 0;
        // OnRootMismatch indicates that the volume ownership will be changed only
        // when the ownership of the root directory does not match with the expected group id for the volume.
        OnRootMismatch = 1;
}

// FSGroup consists of the group id and group ownership change policy
// that a volume should have its ownership changed to.
message FSGroup {
        // GroupID is the ID that the group ownership of the
        // files in the mounted volume will need to be changed to.
        uint32 group_id = 2;
        // GroupChangePolicy specifies the policy for applying group id
        // ownership change on a mounted volume.
        //types.FSGroupChangePolicy group_change_policy = 3;
        FSGroupChangePolicy group_change_policy = 3;
}

message Storage {
        // Driver is used to define the way the storage is passed through the
        // virtual machine. It can be "9p", "blk", or something else, but for
        // all cases, this will define if some extra steps are required before
        // this storage gets mounted into the container.
        string driver = 1;
        // DriverOptions allows the caller to define a list of options such
        // as block sizes, numbers of luns, ... which are very specific to
        // every device and cannot be generalized through extra fields.
        repeated string driver_options = 2;
        // Source can be anything representing the source of the storage. This
        // will be handled by the proper handler based on the Driver used.
        // For instance, it can be a very simple path if the caller knows the
        // name of device inside the VM, or it can be some sort of identifier
        // to let the agent find the device inside the VM.
        string source = 3;
        // Fstype represents the filesystem that needs to be used to mount the
        // storage inside the VM. For instance, it could be "xfs" for block
        // device, "9p" for shared filesystem, or "tmpfs" for shared /dev/shm.
        string fstype = 4;
        // Options describes the additional options that might be needed to
        // mount properly the storage filesystem.
        repeated string options = 5;
        // MountPoint refers to the path where the storage should be mounted
        // inside the VM.
        string mount_point = 6;
        // FSGroup consists of the group ID and group ownership change policy
        // that the mounted volume must have its group ID changed to when specified.
        FSGroup fs_group = 7;
}
